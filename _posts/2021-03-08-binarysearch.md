---
type: single
title: "TIL210308 - "Recursion - Binary Search"
---

이번 장에서는 **Recursion**을 활용한 **Binary Search**에 대해서 다루어 볼 것이다. 

Binary Search는 한국어로 이진 탐색이라는 탐색 알고리즘으로, 정렬된 데이터 안에서 값을 빠르게 찾을 수 있게 도와주는 알고리즘이다. 

N개의 정렬된 데이터 안에서 어떤 값 A를 찾고자 할 때, 순차적으로 인덱스 0부터 N-1까지 탐색할 수 있다. 이 경우 최악의 경우 - 탐색하는 데 가장 시간이 오래 걸리는 경우 - N-1 번을 탐색해야 한다.
A가 N-1번째 인덱스에 있는 경우이다. 

이진 탐색은 최악의 경우에도 밑이 2인 log(n)q번의 탐색횟수를 보장해준다. 즉 데이터가 16개일때 원하는 값을 최대 4번만에 찾아낼 수 있는 것이다. 데이터가 1267650600228229401496703205376개만큼 있더라도,
최대 100번만에 찾아낼 수 있는 것이 이진탐색이다. 어떻게 이것이 가능할까?

정렬된(오름차순 혹은 내림차순 된) 데이터 안에서 데이터의 처음과 끝 인덱스의 중간을 찍어 그것을 원하는 값과 비교한다. 만약 중간값이 원하는 값보다 크다면, 중간값 오른쪽의 데이터는 버리고 왼쪽의 데이터 안에서 같은 탐색을 반복한다.
즉, 데이터의 처음부터 중간값 바로 이전의 데이터에서 다시 중간값을 취해 원하는 값을 비교하는 것이다.

교수님께서 아주 적절한 비유를 해주셨는데, 이는 교과서에서 우리가 특정 페이지를 찾아나가는 과정과 비슷하다. 교수님이 340페이지를 피라고 하셨을 떄, 우리는 (감으로) 처음과 끝의 어떤 지점을 선택해서 해당 페이지 수가 340페이지인지 확인한다.
340페이지보다 크면, 적절한 감으로 다시 0페이지부터 우리가 핀 페이지 중간 어느 지점을 픽해 다시 340과 비교한다. 이진탐색은 처음과 끝의 딱 중간 지점을 선택한다는 점에서 우리가 특정 페이지를 선택하는 알고리즘보다 더 기계적으로 전개되는 알고리즘이라고 할 수 있다. 


이를 재귀(recursion)함수 BinarySearch로 해결해보자. 
먼저 어떤 parameter가 필요할지 생각해보자. 데이터가 저장된 int형 배열과, 우리가 찾고자 하는 값, 그리고 배열의 처음과 끝 인덱스 총 4개의 parameter가 필요하다. 재귀적으로 데이터의 범위를 줄여나갈 떄,
원하는 값을 찾을 경우 그 값이 포함된 정수형 인덱스를 반환할 것이고, 찾지 못했을 경우 -1을 반환환다. 그리고 **base case는 두 가지 경우가 있는데, 하나는 원하는 값을 찾았을 경우, 즉 처음과 끝의 중간지점인 middle 인덱스 안의 포함된 값아진 경우가 원하는 값과 같아진 경우
middle 값을 반환하는 것이고, 다른 하나는 원하는 값을 찾지 못했을 경우에 -1을 반환하도록 하는 것이다. ** 원하는 값이 배열에 없을 경우, 근원적으로 탐색의 시작인덱스가 끝인덱스를 초과하는 것으로 귀결된다. 이 때에 -1을 return 할 수 있도록 하는 것이다.
재귀 함수의 base case가 2개 이상 일 수 있는 것이다!

이를 c언어로 구현해보면 다음과 같다. 

```c
#include <stdio.h>

int BinarySearch(int arr[], int n, int start, int end)
{
	int middle, res;
	middle = (start + end) / 2;
	
	if (start > end) return -1;
	if (arr[middle] > n)
	{
		res = BinarySearch(arr, n, start, middle - 1);
	}
	else if (arr[middle] == n)
	{
		res = middle;
	}
	else
	{
		res = BinarySearch(arr, n, middle + 1, end);
	}
	return res;
}
```

다음과 같은 main함수로써 test해볼 수 있다. 
```c
int main(void)
{
	int arr[10] = {1, 3, 4, 5, 345, 545, 2355, 4534, 6554, 8003};
	int res;
	res = BinarySearch(arr, 6, 0, 9);
	switch(res)
	{
	case -1: printf("찾고자 하는 값이 배열에 없습니다.\n"); break;	
	default : printf("찾고자 하는 값은 %d번째 인덱스가 가리키고 있습니다.\n", res);
	}
	return 0;
}
```

다음에는 순열(permutation)혹은  이항계수(Binomail coefficient)에 대해서 공부해볼 것이다. 





