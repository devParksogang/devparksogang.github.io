---
type: single
title: "TIL210308 - Selection Sort using recursion"
---


이전 페이지에 이어서 선택 정렬에 대해서 계속 이야기해보자. 이번에는 Recursion을 이용한 선택정렬이다.
선택정렬은 데이터 개수 n에 대하여 n번의 반복을 통해서 최솟값을 찾고 정렬을 수행한다. 
이때 최솟값을 찾는 범위는 n부터 1까지 점점 줄어드므로 Recursion을 이용할 수 있다.


순환을 이용하는 함수에서는 반복을 이용한 함수에서보다 parameter가 하나 더 필요하다. 반복 선택정렬에서는 parameter로 배열의 주소와 배열의 크기가 요구됐다면,
순환에서는 최솟값을 찾는 범위가 시작되는 위치 i가 더 필요하다. 즉 첫번째 수행단계에서는 i = 0부터 n-1까지에서 최솟값을 찾아 i = 0에 저장한다. 두번재 수행단계에서는 i = 1에서부터 n-1까지 
최솟값을 찾아 i = 1에 저장한다. 재귀가 deep해질 수록 i의 개수를 하나씩 키워나가는 것이다. 

모든 재귀함수에는 재귀 호출을 멈추는 base case가 필요하다. 재귀 선택정렬함수에서 base case는 더 이상 정렬할 것이 남아 있지 않을 때, 즉 i == n-1일때가 된다.

```c
void sort(int arr[], int n, int i)
{
  if (i == n-1) return;
  
  int min = i;
  int temp;
  
  //최솟값을 찾는다.
  for(int j = i + 1; j < n; j ++)
  {
    if (arr[min] > arr[j]
      min = j;
  }
  //최솟값이 있는 인덱스와 i번째 인덱스를 교환한다. 
  temp = arr[i];
  arr[i] = arr[min];
  arr[min] = temp;
  //--> i번째까지 정렬완료
  
  sort(arr, n, i+1); //i+1번째부터 n-1까지 선택정렬(위 과정)을 반복! 
} 
```

결과값을 확인하기 위해서 다음과 같이 main함수를 짜서 컴파일 해본다. 

```c
int main(void)
{
	int arr[5] = {5, 1, 3, 4, 7};
	sort(arr, 5, 0);
	for(int i = 0; i < 5; i++)
		printf("%d", arr[i]);
		
	return 0;
}
```

재귀(recursion)은 본질적으로 문제의 크기를 줄여나가면서 알고리즘을 반복해나가는 과정이다. 범위를 n에서 n-1에서, 1에서 0까지로 줄여나가면서 더이상 해결할 문제가 없어질 떄까지
만드는 것이다. 아직 재귀가 어렵다. 여러 문제들을 재귀로 풀고 정리해나가면서 재귀함수를 정복해 나가야겠다. 
